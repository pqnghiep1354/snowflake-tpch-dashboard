-- =====================================================
-- PHẦN 3: KHÁM PHÁ & KIỂM TRA DỮ LIỆU
-- Data Profiling, Quality Checks, và Performance Optimization
-- =====================================================

USE ROLE TPCH_ANALYST;
USE DATABASE TPCH_ANALYTICS_DB;
USE WAREHOUSE TPCH_WH;

-- =====================================================
-- 3.1 DATA PROFILING - Khám phá dữ liệu
-- =====================================================

-- 1. Đếm số dòng mỗi bảng (Bronze, Silver, Gold layers)
SELECT 'Bronze Layer - STAGING Schema' AS LAYER;
SELECT '─────────────────────────────────' AS SEPARATOR;

SELECT 'REGION' AS TABLE_NAME, COUNT(*) AS ROW_COUNT FROM STAGING.REGION
UNION ALL SELECT 'NATION', COUNT(*) FROM STAGING.NATION
UNION ALL SELECT 'CUSTOMER', COUNT(*) FROM STAGING.CUSTOMER
UNION ALL SELECT 'SUPPLIER', COUNT(*) FROM STAGING.SUPPLIER
UNION ALL SELECT 'PART', COUNT(*) FROM STAGING.PART
UNION ALL SELECT 'PARTSUPP', COUNT(*) FROM STAGING.PARTSUPP
UNION ALL SELECT 'ORDERS', COUNT(*) FROM STAGING.ORDERS
UNION ALL SELECT 'LINEITEM', COUNT(*) FROM STAGING.LINEITEM
ORDER BY TABLE_NAME;

SELECT '' AS SPACER;
SELECT 'Silver Layer - ANALYTICS Schema' AS LAYER;
SELECT '─────────────────────────────────' AS SEPARATOR;

SELECT 'ORDERS_SILVER' AS TABLE_NAME, COUNT(*) AS ROW_COUNT FROM ANALYTICS.ORDERS_SILVER
UNION ALL SELECT 'CUSTOMER_SILVER', COUNT(*) FROM ANALYTICS.CUSTOMER_SILVER
UNION ALL SELECT 'LINEITEM_SILVER', COUNT(*) FROM ANALYTICS.LINEITEM_SILVER
UNION ALL SELECT 'PART_SILVER', COUNT(*) FROM ANALYTICS.PART_SILVER
UNION ALL SELECT 'SUPPLIER_SILVER', COUNT(*) FROM ANALYTICS.SUPPLIER_SILVER
ORDER BY TABLE_NAME;

SELECT '' AS SPACER;
SELECT 'Gold Layer - REPORTS Schema' AS LAYER;
SELECT '─────────────────────────────────' AS SEPARATOR;

SELECT 'MONTHLY_SALES_REPORT' AS TABLE_NAME, COUNT(*) AS ROW_COUNT FROM REPORTS.MONTHLY_SALES_REPORT
UNION ALL SELECT 'CUSTOMER_METRICS', COUNT(*) FROM REPORTS.CUSTOMER_METRICS
UNION ALL SELECT 'PRODUCT_PERFORMANCE', COUNT(*) FROM REPORTS.PRODUCT_PERFORMANCE
UNION ALL SELECT 'REGIONAL_ANALYSIS', COUNT(*) FROM REPORTS.REGIONAL_ANALYSIS
ORDER BY TABLE_NAME;

-- 2. Phân tích khách hàng theo quốc gia
SELECT 
    N.N_NAME AS COUNTRY,
    R.R_NAME AS REGION,
    COUNT(DISTINCT C.C_CUSTKEY) AS CUSTOMER_COUNT,
    AVG(C.C_ACCTBAL) AS AVG_ACCOUNT_BALANCE,
    SUM(CASE WHEN C.C_ACCTBAL < 0 THEN 1 ELSE 0 END) AS NEGATIVE_BALANCE_COUNT,
    MIN(C.C_ACCTBAL) AS MIN_BALANCE,
    MAX(C.C_ACCTBAL) AS MAX_BALANCE
FROM STAGING.CUSTOMER C
JOIN STAGING.NATION N ON C.C_NATIONKEY = N.N_NATIONKEY
JOIN STAGING.REGION R ON N.N_REGIONKEY = R.R_REGIONKEY
GROUP BY N.N_NAME, R.R_NAME
ORDER BY CUSTOMER_COUNT DESC;

-- 3. Phân tích đơn hàng theo trạng thái
SELECT 
    O_ORDERSTATUS,
    CASE O_ORDERSTATUS
        WHEN 'O' THEN 'Open'
        WHEN 'F' THEN 'Finished'
        WHEN 'P' THEN 'Pending'
        ELSE 'Unknown'
    END AS STATUS_DESCRIPTION,
    COUNT(*) AS ORDER_COUNT,
    SUM(O_TOTALPRICE) AS TOTAL_REVENUE,
    AVG(O_TOTALPRICE) AS AVG_ORDER_VALUE,
    MIN(O_TOTALPRICE) AS MIN_ORDER_VALUE,
    MAX(O_TOTALPRICE) AS MAX_ORDER_VALUE,
    MIN(O_ORDERDATE) AS EARLIEST_ORDER,
    MAX(O_ORDERDATE) AS LATEST_ORDER
FROM STAGING.ORDERS
GROUP BY O_ORDERSTATUS
ORDER BY ORDER_COUNT DESC;

-- 4. Top 10 sản phẩm được bán nhiều nhất
SELECT 
    P.P_PARTKEY,
    P.P_NAME,
    P.P_MFGR,
    P.P_BRAND,
    P.P_TYPE,
    COUNT(DISTINCT L.L_ORDERKEY) AS ORDER_COUNT,
    SUM(L.L_QUANTITY) AS TOTAL_QUANTITY_SOLD,
    SUM(L.L_EXTENDEDPRICE) AS TOTAL_REVENUE,
    AVG(L.L_EXTENDEDPRICE) AS AVG_PRICE,
    AVG(L.L_DISCOUNT) AS AVG_DISCOUNT
FROM STAGING.PART P
JOIN STAGING.LINEITEM L ON P.P_PARTKEY = L.L_PARTKEY
GROUP BY P.P_PARTKEY, P.P_NAME, P.P_MFGR, P.P_BRAND, P.P_TYPE
ORDER BY TOTAL_REVENUE DESC
LIMIT 10;

-- 5. Top 10 khách hàng có doanh thu cao nhất
SELECT 
    C.C_CUSTKEY,
    C.C_NAME,
    N.N_NAME AS COUNTRY,
    R.R_NAME AS REGION,
    C.C_MKTSEGMENT,
    COUNT(DISTINCT O.O_ORDERKEY) AS ORDER_COUNT,
    SUM(O.O_TOTALPRICE) AS TOTAL_REVENUE,
    AVG(O.O_TOTALPRICE) AS AVG_ORDER_VALUE,
    MIN(O.O_ORDERDATE) AS FIRST_ORDER_DATE,
    MAX(O.O_ORDERDATE) AS LAST_ORDER_DATE,
    DATEDIFF('DAY', MAX(O.O_ORDERDATE), CURRENT_DATE()) AS DAYS_SINCE_LAST_ORDER
FROM STAGING.CUSTOMER C
JOIN STAGING.ORDERS O ON C.C_CUSTKEY = O.O_CUSTKEY
JOIN STAGING.NATION N ON C.C_NATIONKEY = N.N_NATIONKEY
JOIN STAGING.REGION R ON N.N_REGIONKEY = R.R_REGIONKEY
GROUP BY C.C_CUSTKEY, C.C_NAME, N.N_NAME, R.R_NAME, C.C_MKTSEGMENT
ORDER BY TOTAL_REVENUE DESC
LIMIT 10;

-- 6. Phân tích xu hướng doanh thu theo thời gian
SELECT 
    YEAR(O_ORDERDATE) AS ORDER_YEAR,
    QUARTER(O_ORDERDATE) AS ORDER_QUARTER,
    MONTH(O_ORDERDATE) AS ORDER_MONTH,
    COUNT(DISTINCT O_ORDERKEY) AS ORDER_COUNT,
    COUNT(DISTINCT O_CUSTKEY) AS UNIQUE_CUSTOMERS,
    SUM(O_TOTALPRICE) AS TOTAL_REVENUE,
    AVG(O_TOTALPRICE) AS AVG_ORDER_VALUE
FROM STAGING.ORDERS
GROUP BY YEAR(O_ORDERDATE), QUARTER(O_ORDERDATE), MONTH(O_ORDERDATE)
ORDER BY ORDER_YEAR, ORDER_QUARTER, ORDER_MONTH;

-- 7. Phân tích nhà cung cấp theo khu vực
SELECT 
    R.R_NAME AS REGION,
    N.N_NAME AS COUNTRY,
    COUNT(DISTINCT S.S_SUPPKEY) AS SUPPLIER_COUNT,
    AVG(S.S_ACCTBAL) AS AVG_ACCOUNT_BALANCE,
    COUNT(DISTINCT PS.PS_PARTKEY) AS UNIQUE_PARTS_SUPPLIED
FROM STAGING.SUPPLIER S
JOIN STAGING.NATION N ON S.S_NATIONKEY = N.N_NATIONKEY
JOIN STAGING.REGION R ON N.N_REGIONKEY = R.R_REGIONKEY
LEFT JOIN STAGING.PARTSUPP PS ON S.S_SUPPKEY = PS.PS_SUPPKEY
GROUP BY R.R_NAME, N.N_NAME
ORDER BY SUPPLIER_COUNT DESC;

-- 8. Phân tích shipping modes
SELECT 
    L_SHIPMODE,
    COUNT(*) AS LINEITEM_COUNT,
    COUNT(DISTINCT L_ORDERKEY) AS ORDER_COUNT,
    SUM(L_QUANTITY) AS TOTAL_QUANTITY,
    SUM(L_EXTENDEDPRICE) AS TOTAL_REVENUE,
    AVG(DATEDIFF('DAY', L_SHIPDATE, L_RECEIPTDATE)) AS AVG_DELIVERY_DAYS,
    SUM(CASE WHEN L_RETURNFLAG = 'R' THEN 1 ELSE 0 END) AS RETURN_COUNT,
    SUM(CASE WHEN L_RETURNFLAG = 'R' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS RETURN_RATE_PCT
FROM STAGING.LINEITEM
GROUP BY L_SHIPMODE
ORDER BY TOTAL_REVENUE DESC;

-- 9. Phân tích priority orders
SELECT 
    O_ORDERPRIORITY,
    COUNT(*) AS ORDER_COUNT,
    SUM(O_TOTALPRICE) AS TOTAL_REVENUE,
    AVG(O_TOTALPRICE) AS AVG_ORDER_VALUE,
    COUNT(DISTINCT O_CUSTKEY) AS UNIQUE_CUSTOMERS
FROM STAGING.ORDERS
GROUP BY O_ORDERPRIORITY
ORDER BY ORDER_COUNT DESC;

-- 10. Phân tích market segments
SELECT 
    C.C_MKTSEGMENT AS MARKET_SEGMENT,
    COUNT(DISTINCT C.C_CUSTKEY) AS CUSTOMER_COUNT,
    COUNT(DISTINCT O.O_ORDERKEY) AS ORDER_COUNT,
    SUM(O.O_TOTALPRICE) AS TOTAL_REVENUE,
    AVG(O.O_TOTALPRICE) AS AVG_ORDER_VALUE,
    SUM(O.O_TOTALPRICE) / COUNT(DISTINCT C.C_CUSTKEY) AS REVENUE_PER_CUSTOMER
FROM STAGING.CUSTOMER C
LEFT JOIN STAGING.ORDERS O ON C.C_CUSTKEY = O.O_CUSTKEY
GROUP BY C.C_MKTSEGMENT
ORDER BY TOTAL_REVENUE DESC;

-- =====================================================
-- 3.2 DATA QUALITY CHECKS
-- =====================================================

SELECT '═════════════════════════════════' AS SEPARATOR;
SELECT 'DATA QUALITY CHECKS' AS SECTION;
SELECT '═════════════════════════════════' AS SEPARATOR;

-- 1. Kiểm tra NULL values trong các cột quan trọng

-- CUSTOMER table
SELECT 'CUSTOMER - NULL Checks' AS CHECK_NAME;
SELECT 
    SUM(CASE WHEN C_CUSTKEY IS NULL THEN 1 ELSE 0 END) AS NULL_CUSTKEY,
    SUM(CASE WHEN C_NAME IS NULL THEN 1 ELSE 0 END) AS NULL_NAME,
    SUM(CASE WHEN C_ADDRESS IS NULL THEN 1 ELSE 0 END) AS NULL_ADDRESS,
    SUM(CASE WHEN C_NATIONKEY IS NULL THEN 1 ELSE 0 END) AS NULL_NATIONKEY,
    SUM(CASE WHEN C_PHONE IS NULL THEN 1 ELSE 0 END) AS NULL_PHONE,
    SUM(CASE WHEN C_ACCTBAL IS NULL THEN 1 ELSE 0 END) AS NULL_ACCTBAL,
    SUM(CASE WHEN C_MKTSEGMENT IS NULL THEN 1 ELSE 0 END) AS NULL_MKTSEGMENT
FROM STAGING.CUSTOMER;

-- ORDERS table
SELECT 'ORDERS - NULL Checks' AS CHECK_NAME;
SELECT 
    SUM(CASE WHEN O_ORDERKEY IS NULL THEN 1 ELSE 0 END) AS NULL_ORDERKEY,
    SUM(CASE WHEN O_CUSTKEY IS NULL THEN 1 ELSE 0 END) AS NULL_CUSTKEY,
    SUM(CASE WHEN O_ORDERSTATUS IS NULL THEN 1 ELSE 0 END) AS NULL_ORDERSTATUS,
    SUM(CASE WHEN O_TOTALPRICE IS NULL THEN 1 ELSE 0 END) AS NULL_TOTALPRICE,
    SUM(CASE WHEN O_ORDERDATE IS NULL THEN 1 ELSE 0 END) AS NULL_ORDERDATE
FROM STAGING.ORDERS;

-- LINEITEM table
SELECT 'LINEITEM - NULL Checks' AS CHECK_NAME;
SELECT 
    SUM(CASE WHEN L_ORDERKEY IS NULL THEN 1 ELSE 0 END) AS NULL_ORDERKEY,
    SUM(CASE WHEN L_PARTKEY IS NULL THEN 1 ELSE 0 END) AS NULL_PARTKEY,
    SUM(CASE WHEN L_SUPPKEY IS NULL THEN 1 ELSE 0 END) AS NULL_SUPPKEY,
    SUM(CASE WHEN L_QUANTITY IS NULL THEN 1 ELSE 0 END) AS NULL_QUANTITY,
    SUM(CASE WHEN L_EXTENDEDPRICE IS NULL THEN 1 ELSE 0 END) AS NULL_EXTENDEDPRICE,
    SUM(CASE WHEN L_SHIPDATE IS NULL THEN 1 ELSE 0 END) AS NULL_SHIPDATE
FROM STAGING.LINEITEM;

-- 2. Kiểm tra duplicates trong primary keys

SELECT 'Duplicate Primary Key Checks' AS CHECK_NAME;

-- CUSTOMER duplicates
SELECT 
    'CUSTOMER' AS TABLE_NAME,
    C_CUSTKEY,
    COUNT(*) AS DUPLICATE_COUNT
FROM STAGING.CUSTOMER
GROUP BY C_CUSTKEY
HAVING COUNT(*) > 1
LIMIT 10;

-- ORDERS duplicates
SELECT 
    'ORDERS' AS TABLE_NAME,
    O_ORDERKEY,
    COUNT(*) AS DUPLICATE_COUNT
FROM STAGING.ORDERS
GROUP BY O_ORDERKEY
HAVING COUNT(*) > 1
LIMIT 10;

-- LINEITEM duplicates (composite key)
SELECT 
    'LINEITEM' AS TABLE_NAME,
    L_ORDERKEY,
    L_LINENUMBER,
    COUNT(*) AS DUPLICATE_COUNT
FROM STAGING.LINEITEM
GROUP BY L_ORDERKEY, L_LINENUMBER
HAVING COUNT(*) > 1
LIMIT 10;

-- 3. Kiểm tra referential integrity

SELECT 'Referential Integrity Checks' AS CHECK_NAME;

-- Customers with invalid nation keys
SELECT 
    'Invalid NATION references in CUSTOMER' AS CHECK_NAME,
    COUNT(*) AS INVALID_COUNT
FROM STAGING.CUSTOMER C
LEFT JOIN STAGING.NATION N ON C.C_NATIONKEY = N.N_NATIONKEY
WHERE N.N_NATIONKEY IS NULL;

-- Orders with invalid customer keys
SELECT 
    'Invalid CUSTOMER references in ORDERS' AS CHECK_NAME,
    COUNT(*) AS INVALID_COUNT
FROM STAGING.ORDERS O
LEFT JOIN STAGING.CUSTOMER C ON O.O_CUSTKEY = C.C_CUSTKEY
WHERE C.C_CUSTKEY IS NULL;

-- Lineitems with invalid order keys
SELECT 
    'Invalid ORDER references in LINEITEM' AS CHECK_NAME,
    COUNT(*) AS INVALID_COUNT
FROM STAGING.LINEITEM L
LEFT JOIN STAGING.ORDERS O ON L.L_ORDERKEY = O.O_ORDERKEY
WHERE O.O_ORDERKEY IS NULL;

-- Lineitems with invalid part keys
SELECT 
    'Invalid PART references in LINEITEM' AS CHECK_NAME,
    COUNT(*) AS INVALID_COUNT
FROM STAGING.LINEITEM L
LEFT JOIN STAGING.PART P ON L.L_PARTKEY = P.P_PARTKEY
WHERE P.P_PARTKEY IS NULL;

-- 4. Kiểm tra business logic constraints

SELECT 'Business Logic Checks' AS CHECK_NAME;

-- Orders với negative prices
SELECT 
    'Orders with negative total price' AS CHECK_NAME,
    COUNT(*) AS VIOLATION_COUNT
FROM STAGING.ORDERS
WHERE O_TOTALPRICE < 0;

-- Lineitems với quantity <= 0
SELECT 
    'Lineitems with invalid quantity' AS CHECK_NAME,
    COUNT(*) AS VIOLATION_COUNT
FROM STAGING.LINEITEM
WHERE L_QUANTITY <= 0;

-- Lineitems với invalid discount (should be between 0 and 1)
SELECT 
    'Lineitems with invalid discount' AS CHECK_NAME,
    COUNT(*) AS VIOLATION_COUNT
FROM STAGING.LINEITEM
WHERE L_DISCOUNT < 0 OR L_DISCOUNT > 1;

-- Lineitems với ship date trước commit date
SELECT 
    'Lineitems with shipdate before commitdate' AS CHECK_NAME,
    COUNT(*) AS VIOLATION_COUNT
FROM STAGING.LINEITEM
WHERE L_SHIPDATE < L_COMMITDATE;

-- Orders trong tương lai
SELECT 
    'Orders with future dates' AS CHECK_NAME,
    COUNT(*) AS VIOLATION_COUNT
FROM STAGING.ORDERS
WHERE O_ORDERDATE > CURRENT_DATE();

-- 5. Statistical outliers detection

SELECT 'Statistical Outlier Detection' AS CHECK_NAME;

-- Orders với abnormally high values (> 3 standard deviations)
WITH stats AS (
    SELECT 
        AVG(O_TOTALPRICE) AS mean_price,
        STDDEV(O_TOTALPRICE) AS stddev_price
    FROM STAGING.ORDERS
)
SELECT 
    'Orders with abnormally high values' AS CHECK_NAME,
    COUNT(*) AS OUTLIER_COUNT,
    MIN(O_TOTALPRICE) AS MIN_OUTLIER,
    MAX(O_TOTALPRICE) AS MAX_OUTLIER
FROM STAGING.ORDERS, stats
WHERE O_TOTALPRICE > (mean_price + 3 * stddev_price);

-- 6. Data completeness check
SELECT 'Data Completeness Report' AS CHECK_NAME;

SELECT 
    'CUSTOMER' AS TABLE_NAME,
    COUNT(*) AS TOTAL_ROWS,
    COUNT(C_CUSTKEY) AS NON_NULL_CUSTKEY,
    COUNT(C_NAME) AS NON_NULL_NAME,
    COUNT(C_PHONE) AS NON_NULL_PHONE,
    COUNT(C_ACCTBAL) AS NON_NULL_ACCTBAL,
    ROUND(COUNT(C_PHONE) * 100.0 / COUNT(*), 2) AS PHONE_COMPLETENESS_PCT,
    ROUND(COUNT(C_ACCTBAL) * 100.0 / COUNT(*), 2) AS ACCTBAL_COMPLETENESS_PCT
FROM STAGING.CUSTOMER;

-- =====================================================
-- 3.3 PERFORMANCE OPTIMIZATION với EXPLAIN
-- =====================================================

SELECT '═════════════════════════════════' AS SEPARATOR;
SELECT 'QUERY PERFORMANCE ANALYSIS' AS SECTION;
SELECT '═════════════════════════════════' AS SEPARATOR;

-- Query 1: Simple aggregation - Check execution plan
EXPLAIN
SELECT 
    O_ORDERPRIORITY,
    COUNT(*) AS ORDER_COUNT,
    SUM(O_TOTALPRICE) AS TOTAL_REVENUE
FROM STAGING.ORDERS
GROUP BY O_ORDERPRIORITY;

-- Query 2: Complex join - Analyze join strategy
EXPLAIN
SELECT 
    C.C_NAME,
    N.N_NAME AS NATION,
    R.R_NAME AS REGION,
    COUNT(O.O_ORDERKEY) AS ORDER_COUNT,
    SUM(O.O_TOTALPRICE) AS TOTAL_REVENUE
FROM STAGING.CUSTOMER C
JOIN STAGING.NATION N ON C.C_NATIONKEY = N.N_NATIONKEY
JOIN STAGING.REGION R ON N.N_REGIONKEY = R.R_REGIONKEY
LEFT JOIN STAGING.ORDERS O ON C.C_CUSTKEY = O.O_CUSTKEY
GROUP BY C.C_NAME, N.N_NAME, R.R_NAME
ORDER BY TOTAL_REVENUE DESC
LIMIT 100;

-- Query 3: Multi-table join with filtering
EXPLAIN
SELECT 
    P.P_NAME,
    S.S_NAME,
    N.N_NAME AS SUPPLIER_NATION,
    SUM(L.L_QUANTITY) AS TOTAL_QUANTITY,
    SUM(L.L_EXTENDEDPRICE * (1 - L.L_DISCOUNT)) AS TOTAL_REVENUE
FROM STAGING.LINEITEM L
JOIN STAGING.PART P ON L.L_PARTKEY = P.P_PARTKEY
JOIN STAGING.SUPPLIER S ON L.L_SUPPKEY = S.S_SUPPKEY
JOIN STAGING.NATION N ON S.S_NATIONKEY = N.N_NATIONKEY
WHERE L.L_SHIPDATE >= '1995-01-01'
  AND L.L_SHIPDATE < '1995-12-31'
GROUP BY P.P_NAME, S.S_NAME, N.N_NAME
ORDER BY TOTAL_REVENUE DESC
LIMIT 50;

-- Query 4: Window function analysis
EXPLAIN
SELECT 
    O_ORDERKEY,
    O_CUSTKEY,
    O_ORDERDATE,
    O_TOTALPRICE,
    ROW_NUMBER() OVER (PARTITION BY O_CUSTKEY ORDER BY O_ORDERDATE DESC) AS ORDER_RANK,
    SUM(O_TOTALPRICE) OVER (PARTITION BY O_CUSTKEY) AS CUSTOMER_LIFETIME_VALUE
FROM STAGING.ORDERS
WHERE O_ORDERDATE >= '1995-01-01';

-- Query 5: Subquery performance
EXPLAIN
SELECT 
    C.C_NAME,
    C.C_ACCTBAL,
    (SELECT COUNT(*) FROM STAGING.ORDERS O WHERE O.O_CUSTKEY = C.C_CUSTKEY) AS ORDER_COUNT,
    (SELECT SUM(O.O_TOTALPRICE) FROM STAGING.ORDERS O WHERE O.O_CUSTKEY = C.C_CUSTKEY) AS TOTAL_REVENUE
FROM STAGING.CUSTOMER C
WHERE C.C_ACCTBAL > 5000;

-- =====================================================
-- QUERY PROFILE ANALYSIS RECOMMENDATIONS
-- =====================================================

SELECT 'Query Profile Analysis Recommendations:' AS INFO;
SELECT '1. After running queries, check Query History in Snowsight UI' AS STEP
UNION ALL SELECT '2. Click on query ID to view detailed Query Profile'
UNION ALL SELECT '3. Look for:' 
UNION ALL SELECT '   - Execution time breakdown'
UNION ALL SELECT '   - Data spilling (indicates memory pressure)'
UNION ALL SELECT '   - Table scan vs. index usage'
UNION ALL SELECT '   - Join types and strategies'
UNION ALL SELECT '   - Partition pruning effectiveness'
UNION ALL SELECT '4. Optimization opportunities:'
UNION ALL SELECT '   - Add clustering keys for frequently filtered columns'
UNION ALL SELECT '   - Use materialized views for complex aggregations'
UNION ALL SELECT '   - Consider result caching for repeated queries'
UNION ALL SELECT '   - Optimize join order for large tables';

-- =====================================================
-- CLUSTERING AND OPTIMIZATION RECOMMENDATIONS
-- =====================================================

-- Check table storage metrics
SELECT 
    TABLE_SCHEMA,
    TABLE_NAME,
    ROW_COUNT,
    BYTES,
    ROUND(BYTES / 1024 / 1024 / 1024, 2) AS SIZE_GB,
    CLUSTERING_KEY
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA IN ('STAGING', 'ANALYTICS', 'REPORTS')
  AND TABLE_TYPE = 'BASE TABLE'
ORDER BY BYTES DESC;

-- Suggest clustering keys for large tables
SELECT 'Clustering Key Recommendations:' AS INFO;
SELECT '1. ORDERS table: Cluster by O_ORDERDATE for date-range queries' AS RECOMMENDATION
UNION ALL SELECT '2. LINEITEM table: Cluster by L_SHIPDATE for time-series analysis'
UNION ALL SELECT '3. CUSTOMER table: Cluster by C_NATIONKEY for regional queries'
UNION ALL SELECT '4. Consider multi-column clustering for complex queries';

-- =====================================================
-- TỔNG KẾT
-- =====================================================

SELECT '✅ PHẦN 3 HOÀN THÀNH!' AS STATUS;
SELECT 'Data Profiling, Quality Checks, và Performance Analysis đã hoàn tất!' AS MESSAGE;
SELECT 'Các insights chính:' AS SECTION
UNION ALL SELECT '  - Data quality: Kiểm tra NULLs, duplicates, referential integrity'
UNION ALL SELECT '  - Business logic: Validate constraints và business rules'
UNION ALL SELECT '  - Performance: EXPLAIN plans và optimization recommendations'
UNION ALL SELECT '  - Clustering: Suggestions for large table optimization';
